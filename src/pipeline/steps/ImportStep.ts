import { BaseStep } from './BaseStep';
import { 
  CardData, 
  WorkflowSettings, 
  ValidationResult, 
  PreviewData,
  PDFDocument,
  ImportSettings,
  PDFMode,
  PageSetting
} from '../types';
import { DPI_CONSTANTS } from '../../constants';
import { DEFAULT_SETTINGS, getDefaultGrid } from '../../defaults';

/**
 * ImportStep - Handles PDF import and page configuration in the transformation pipeline
 * 
 * This step is responsible for:
 * - Loading PDF documents from file input
 * - Configuring PDF mode (duplex vs gutter-fold)
 * - Setting up page configurations (skip, front/back designation)
 * - Generating preview thumbnails of PDF pages
 * - Providing initial card count estimates based on grid configuration
 */
export class ImportStep extends BaseStep {
  private pdfDocument: PDFDocument | null = null;
  private fileName: string = '';
  private pageSettings: PageSetting[] = [];
  private pdfMode: PDFMode = DEFAULT_SETTINGS.pdfMode;

  constructor() {
    super('import', 'Import PDF', 'Load PDF document and configure page settings');
  }
  /**
   * Execute the import step - processes PDF data and page configurations
   */
  async execute(_input: CardData[], settings: WorkflowSettings): Promise<CardData[]> {
    try {
      // Import step doesn't modify card data directly, it prepares the PDF for processing
      // The actual card data will be generated by subsequent steps (configure/extract)
      
      // Validate that we have PDF data and settings
      const importSettings = this.getImportSettings(settings);
      if (!importSettings.pdfData) {
        throw new Error('No PDF document loaded');
      }      // Store PDF processing info in settings for downstream steps
      // Note: In a full implementation, this would update the pipeline state
      // For now, we just validate the import configuration

      // Update internal state
      this.pdfDocument = importSettings.pdfData;
      this.fileName = importSettings.fileName || 'Unknown PDF';
      this.pageSettings = importSettings.pageSettings;
      this.pdfMode = importSettings.pdfMode;

      // Return empty card data - cards will be generated in extract step
      return [];
    } catch (error) {
      console.error('ImportStep execution failed:', error);
      throw new Error(`Failed to process PDF import: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }
  /**
   * Generate preview showing PDF pages and configuration
   */
  async generatePreview(_input: CardData[], settings: WorkflowSettings): Promise<PreviewData> {
    try {
      const importSettings = this.getImportSettings(settings);
      
      if (!importSettings.pdfData || !this.pdfDocument) {
        // Return a placeholder preview when no PDF is loaded
        return this.createPlaceholderPreview();
      }

      // Generate preview showing first page and configuration summary
      const previewCanvas = await this.createImportPreview(importSettings);
      const imageUrl = previewCanvas.toDataURL('image/png', 0.8);

      return {
        imageUrl,
        thumbnailUrl: imageUrl, // Use same image for thumbnail for now
        metadata: {
          width: previewCanvas.width,
          height: previewCanvas.height,
          dpi: DPI_CONSTANTS.SCREEN_DPI,
          renderTime: Date.now(),
          stepId: this.id,
          timestamp: Date.now()
        }
      };
    } catch (error) {
      console.error('ImportStep preview generation failed:', error);
      throw new Error(`Failed to generate import preview: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Validate import settings
   */
  validate(settings: WorkflowSettings): ValidationResult {
    const errors = [];
    const warnings = [];

    try {
      const importSettings = this.getImportSettings(settings);

      // Check if PDF document is loaded
      if (!importSettings.pdfData) {
        errors.push({
          field: 'pdfData',
          message: 'No PDF document loaded',
          code: 'MISSING_PDF'
        });
      } else {
        // Validate page count
        if (importSettings.pdfData.numPages <= 0) {
          errors.push({
            field: 'pdfData.numPages',
            message: 'PDF document has no pages',
            code: 'INVALID_PAGE_COUNT'
          });
        }

        // Validate page settings
        if (!Array.isArray(importSettings.pageSettings)) {
          errors.push({
            field: 'pageSettings',
            message: 'Page settings must be an array',
            code: 'INVALID_PAGE_SETTINGS'
          });
        } else if (importSettings.pageSettings.length !== importSettings.pdfData.numPages) {
          warnings.push({
            field: 'pageSettings',
            message: `Page settings count (${importSettings.pageSettings.length}) doesn't match PDF page count (${importSettings.pdfData.numPages})`,
            code: 'PAGE_SETTINGS_MISMATCH'
          });
        }

        // Check if all pages are skipped
        const validPages = this.getValidPageIndices(importSettings.pageSettings);
        if (validPages.length === 0) {
          warnings.push({
            field: 'pageSettings',
            message: 'All pages are marked as skipped - no cards will be extracted',
            code: 'ALL_PAGES_SKIPPED'
          });
        }
      }

      // Validate PDF mode
      if (!importSettings.pdfMode || typeof importSettings.pdfMode !== 'object') {
        errors.push({
          field: 'pdfMode',
          message: 'Invalid PDF mode configuration',
          code: 'INVALID_PDF_MODE'
        });
      } else {
        const { type, orientation, flipEdge } = importSettings.pdfMode;
        
        if (!['duplex', 'gutter-fold'].includes(type)) {
          errors.push({
            field: 'pdfMode.type',
            message: 'PDF mode type must be "duplex" or "gutter-fold"',
            code: 'INVALID_PDF_MODE_TYPE'
          });
        }

        if (!['vertical', 'horizontal'].includes(orientation)) {
          errors.push({
            field: 'pdfMode.orientation',
            message: 'PDF mode orientation must be "vertical" or "horizontal"',
            code: 'INVALID_PDF_ORIENTATION'
          });
        }

        if (!['short', 'long'].includes(flipEdge)) {
          errors.push({
            field: 'pdfMode.flipEdge',
            message: 'PDF mode flip edge must be "short" or "long"',
            code: 'INVALID_PDF_FLIP_EDGE'
          });
        }
      }

    } catch (error) {
      errors.push({
        field: 'general',
        message: `Validation error: ${error instanceof Error ? error.message : 'Unknown error'}`,
        code: 'VALIDATION_ERROR'
      });
    }

    return {
      valid: errors.length === 0,
      errors,
      warnings
    };
  }
  /**
   * Get cache key for import step
   */
  getCacheKey(_input: CardData[], settings: WorkflowSettings): string {
    const importSettings = this.getImportSettings(settings);
    const pdfFingerprint = importSettings.pdfData?.fingerprint || 'no-pdf';
    const pageSettingsHash = JSON.stringify(importSettings.pageSettings);
    const modeHash = JSON.stringify(importSettings.pdfMode);
    
    return `import-${pdfFingerprint}-${this.hashString(pageSettingsHash)}-${this.hashString(modeHash)}`;
  }

  // ======================== Helper Methods ========================

  /**
   * Extract import settings from workflow settings
   */
  private getImportSettings(settings: WorkflowSettings): ImportSettings {
    // Import settings are stored in custom properties on WorkflowSettings
    const settingsAny = settings as any;
    return {
      pdfData: settingsAny.pdfData || null,
      pdfMode: settingsAny.pdfMode || DEFAULT_SETTINGS.pdfMode,
      pageSettings: settingsAny.pageSettings || [],
      fileName: settingsAny.fileName || ''
    };
  }

  /**
   * Get array of valid (non-skipped) page indices
   */
  private getValidPageIndices(pageSettings: PageSetting[]): number[] {
    return pageSettings
      .map((page, index) => ({ page, index }))
      .filter(({ page }) => !page.skip)
      .map(({ index }) => index);
  }

  /**
   * Create placeholder preview when no PDF is loaded
   */
  private createPlaceholderPreview(): PreviewData {
    const canvas = document.createElement('canvas');
    canvas.width = 400;
    canvas.height = 300;
    
    const ctx = canvas.getContext('2d')!;
    ctx.fillStyle = '#f3f4f6';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    ctx.fillStyle = '#6b7280';
    ctx.font = '16px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('No PDF loaded', canvas.width / 2, canvas.height / 2 - 10);
    ctx.fillText('Upload a PDF file to begin', canvas.width / 2, canvas.height / 2 + 20);

    return {
      imageUrl: canvas.toDataURL('image/png'),
      thumbnailUrl: canvas.toDataURL('image/png'),
      metadata: {
        width: canvas.width,
        height: canvas.height,
        dpi: DPI_CONSTANTS.SCREEN_DPI,
        renderTime: Date.now(),
        stepId: this.id,
        timestamp: Date.now()
      }
    };
  }

  /**
   * Create preview showing PDF pages and import configuration
   */
  private async createImportPreview(importSettings: ImportSettings): Promise<HTMLCanvasElement> {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d')!;
    
    // Set canvas size
    canvas.width = 600;
    canvas.height = 400;
    
    // Clear background
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    try {
      // If we have PDF data, try to render the first page as a thumbnail
      if (importSettings.pdfData && this.pdfDocument) {
        await this.renderPDFPreview(ctx, importSettings);
      }
      
      // Add configuration info
      this.renderConfigurationInfo(ctx, importSettings);
      
    } catch (error) {
      console.warn('Failed to render PDF preview:', error);
      this.renderErrorInfo(ctx, 'Preview unavailable');
    }

    return canvas;
  }

  /**
   * Render PDF page preview (first non-skipped page)
   */
  private async renderPDFPreview(ctx: CanvasRenderingContext2D, importSettings: ImportSettings): Promise<void> {
    // This is a simplified preview - in a real implementation, you'd need access to PDF.js
    // For now, we'll just show configuration information
    
    const validPages = this.getValidPageIndices(importSettings.pageSettings);
    const firstPageIndex = validPages[0] ?? 0;
    
    // Draw placeholder page
    const pageX = 50;
    const pageY = 50;
    const pageWidth = 200;
    const pageHeight = 280;
    
    // Page background
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(pageX, pageY, pageWidth, pageHeight);
    
    // Page border
    ctx.strokeStyle = '#d1d5db';
    ctx.lineWidth = 2;
    ctx.strokeRect(pageX, pageY, pageWidth, pageHeight);
    
    // Page number
    ctx.fillStyle = '#374151';
    ctx.font = '14px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(`Page ${firstPageIndex + 1}`, pageX + pageWidth / 2, pageY + pageHeight / 2);
    
    // Grid overlay
    const grid = getDefaultGrid(importSettings.pdfMode);
    const cellWidth = pageWidth / grid.columns;
    const cellHeight = pageHeight / grid.rows;
    
    ctx.strokeStyle = '#3b82f6';
    ctx.lineWidth = 1;
    ctx.setLineDash([5, 5]);
    
    // Draw grid
    for (let row = 1; row < grid.rows; row++) {
      const y = pageY + row * cellHeight;
      ctx.beginPath();
      ctx.moveTo(pageX, y);
      ctx.lineTo(pageX + pageWidth, y);
      ctx.stroke();
    }
    
    for (let col = 1; col < grid.columns; col++) {
      const x = pageX + col * cellWidth;
      ctx.beginPath();
      ctx.moveTo(x, pageY);
      ctx.lineTo(x, pageY + pageHeight);
      ctx.stroke();
    }
    
    ctx.setLineDash([]);
  }

  /**
   * Render configuration information
   */
  private renderConfigurationInfo(ctx: CanvasRenderingContext2D, importSettings: ImportSettings): void {
    const infoX = 300;
    const infoY = 60;
    
    ctx.fillStyle = '#374151';
    ctx.font = 'bold 16px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('Import Configuration', infoX, infoY);
    
    ctx.font = '14px sans-serif';
    const lineHeight = 24;
    let currentY = infoY + 30;
    
    // File info
    ctx.fillText(`File: ${importSettings.fileName || 'Unknown'}`, infoX, currentY);
    currentY += lineHeight;
    
    if (importSettings.pdfData) {
      ctx.fillText(`Pages: ${importSettings.pdfData.numPages}`, infoX, currentY);
      currentY += lineHeight;
    }
    
    // PDF mode
    ctx.fillText(`Mode: ${importSettings.pdfMode.type}`, infoX, currentY);
    currentY += lineHeight;
    
    if (importSettings.pdfMode.type === 'duplex') {
      ctx.fillText(`Flip Edge: ${importSettings.pdfMode.flipEdge}`, infoX, currentY);
    } else {
      ctx.fillText(`Orientation: ${importSettings.pdfMode.orientation}`, infoX, currentY);
    }
    currentY += lineHeight;
    
    // Grid info
    const grid = getDefaultGrid(importSettings.pdfMode);
    ctx.fillText(`Grid: ${grid.rows} × ${grid.columns}`, infoX, currentY);
    currentY += lineHeight;
    
    // Page status
    const validPages = this.getValidPageIndices(importSettings.pageSettings);
    const skippedPages = importSettings.pageSettings.length - validPages.length;
    
    ctx.fillText(`Active Pages: ${validPages.length}`, infoX, currentY);
    currentY += lineHeight;
    
    if (skippedPages > 0) {
      ctx.fillStyle = '#ef4444';
      ctx.fillText(`Skipped Pages: ${skippedPages}`, infoX, currentY);
    }
  }

  /**
   * Render error information
   */
  private renderErrorInfo(ctx: CanvasRenderingContext2D, message: string): void {
    ctx.fillStyle = '#ef4444';
    ctx.font = '16px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(message, ctx.canvas.width / 2, ctx.canvas.height / 2);
  }

  /**
   * Simple string hashing for cache keys
   */
  private hashString(str: string): string {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convert to 32bit integer
    }
    return Math.abs(hash).toString(36);
  }

  // ======================== Public API Methods ========================

  /**
   * Set PDF document and basic configuration
   */
  async setPDFDocument(pdfDocument: PDFDocument, fileName: string): Promise<void> {
    this.pdfDocument = pdfDocument;
    this.fileName = fileName;
    
    // Initialize page settings with defaults
    this.pageSettings = Array(pdfDocument.numPages).fill(null).map((_, i) => ({
      skip: false,
      type: i % 2 === 0 ? 'front' : 'back' // Default alternating for duplex
    }));
  }

  /**
   * Update PDF mode configuration
   */
  setPDFMode(pdfMode: PDFMode): void {
    this.pdfMode = { ...pdfMode };
  }

  /**
   * Update page settings
   */
  setPageSettings(pageSettings: PageSetting[]): void {
    this.pageSettings = [...pageSettings];
  }

  /**
   * Get current import configuration
   */
  getImportConfiguration(): ImportSettings {
    return {
      pdfData: this.pdfDocument,
      pdfMode: this.pdfMode,
      pageSettings: this.pageSettings,
      fileName: this.fileName
    };
  }

  /**
   * Get estimated card count based on current configuration
   */
  getEstimatedCardCount(): number {
    if (!this.pdfDocument) return 0;
    
    const validPages = this.getValidPageIndices(this.pageSettings);
    const grid = getDefaultGrid(this.pdfMode);
    const cardsPerPage = grid.rows * grid.columns;
    
    return validPages.length * cardsPerPage;
  }
}
